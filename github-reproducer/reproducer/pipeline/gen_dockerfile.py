"""
Generates a Dockerfile for the job we want to reproduce, so we can spawn a container of the image built from that
Dockerfile and then run the job. gen_dockerfile.py does the following:
1. reads the .travis.yml to determine what language-named image to use
2. ADDs the script generated by travis-build into the container
3. switches to USER travis
4. runs the added script when a container is spawned.
"""
from bugswarm.common import log


def gen_dockerfile(image_tag: str, job_id: str, destination: str = None):
    """
    Generates a Dockerfile for reproducing a job.

    This only requires that we know which Travis base image from which to derive the generated Dockerfile.

    :param image_tag: The image tag that the original build used. This image tag will be used as the base image.
    :param job_id: The job ID identifying the original Travis job.
    :param destination: Path where the generated Dockerfile should be written.
    """
    log.info('Selecting Docker image to use for reproducing this job.')

    # TODO: Remove this block to other file.
    destination = destination or job_id + '-Dockerfile'
    image_tags = {
        'ubuntu-latest': 'bugswarm/githubactionsjobrunners:ubuntu-20.04',
        'ubuntu-20.04': 'bugswarm/githubactionsjobrunners:ubuntu-20.04',
        'ubuntu-18.04': 'bugswarm/githubactionsjobrunners:ubuntu-18.04'
    }

    if image_tag not in image_tags:
        base_image = image_tags['ubuntu-latest']
        log.debug('Unknown GitHub image tag {}, use {} instead'.format(image_tag, base_image))
    else:
        base_image = image_tags[image_tag]
        log.debug('GitHub image tag is {}, use base image {}'.format(image_tag, base_image))

    _write_dockerfile(destination, base_image, job_id)
    log.debug('Wrote Dockerfile to {}'.format(destination))


def _write_dockerfile(destination: str, base_image: str, job_id: str):
    lines = [
        'FROM {}'.format(base_image),
        # Remove PPA and clean APT
        'RUN sudo rm -rf /var/lib/apt/lists/*',
        'RUN sudo rm -rf /etc/apt/sources.list.d/*',
        'RUN sudo apt-get clean',

        # Update OpenSSL and libssl to avoid using deprecated versions of TLS (TLSv1.0 and TLSv1.1).
        # TODO: Do we actually only want to do this when deriving from an image that has an out-of-date version of TLS?
        'RUN sudo apt-get update && sudo apt-get install --only-upgrade openssl libssl-dev',
        # TODO: Install vim for dev
        'RUN sudo apt-get install vim',

        # Otherwise: docker: Error response from daemon: unable to find user github: no matching entries in passwd file.
        'RUN useradd -ms /bin/bash github',

        # Add the repository.
        'ADD repo-to-docker.tar /home/github/build/',
        'RUN chmod 777 -R /home/github/build',

        # Add the build script and predefined actions.
        'ADD {}/run.sh /usr/local/bin/'.format(job_id),
        'ADD {}/actions /home/github/actions'.format(job_id),
        'RUN chmod ugo+x /usr/local/bin/run.sh',
        'RUN chmod -R 777 /home/github/actions',

        # TODO: Find this doc
        # Set the user to use when running the image. Our Google Drive contains a file that explains why we do this.
        'USER github',

        # Need bash, otherwise: Syntax error: redirection unexpected
        'ENTRYPOINT ["/bin/bash", "-c"]',
        # Run the build script.
        'CMD ["/usr/local/bin/run.sh"]',
    ]
    # Append a newline to each line and then concatenate all the lines.
    content = ''.join(map(lambda l: l + '\n', lines))
    with open(destination, 'w') as f:
        f.write(content)
