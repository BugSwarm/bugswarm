import argparse
import csv
import json
import os
import sys
import tempfile

from bugswarm.common import log
from bugswarm.common.credentials import DATABASE_PIPELINE_TOKEN
from bugswarm.common.diff_calculator import gather_diff
from bugswarm.common.rest_api.database_api import DatabaseAPI


def _add_diff_for_artifact(image_tag, build_pair, clone_path):
    log.info('Getting diff for {}'.format(image_tag))

    failed_head_sha = build_pair['failed_build']['head_sha']
    failed_base_sha = build_pair['failed_build']['base_sha'] or None
    failed_merge_sha = build_pair['failed_build']['travis_merge_sha'] or None
    passed_head_sha = build_pair['passed_build']['head_sha']
    passed_base_sha = build_pair['passed_build']['base_sha'] or None
    passed_merge_sha = build_pair['passed_build']['travis_merge_sha'] or None
    repo = build_pair['repo']

    diff_data = gather_diff(failed_head_sha, passed_head_sha, repo, clone_path, failed_base_sha, passed_base_sha)
    diff_data['image_tag'] = image_tag

    # If we have a merge commit, then failed_sha and passed_sha will not be present in the GitHub repository since we
    # simulate merge commits. Set them to the SHAs that actually have a chance of being in repository.
    if failed_merge_sha:
        diff_data['failed_sha'] = failed_merge_sha
    if passed_merge_sha:
        diff_data['passed_sha'] = passed_merge_sha

    log.info('Uploading diff for {} to database'.format(image_tag))
    bugswarmapi = DatabaseAPI(DATABASE_PIPELINE_TOKEN)
    result = bugswarmapi.set_diff(**diff_data)
    if result.ok:
        log.info('Successfully uploaded diff for {}'.format(image_tag))
    else:
        log.error('Error uploading diff for {}: {}'.format(image_tag, result))


def _validate_input():
    p = argparse.ArgumentParser()
    p.add_argument('-j', '--build-pair-json', required=True,
                   help='A JSON file containing the build pairs for the jobs to upload diffs for.')
    p.add_argument('-c', '--cacher-csv', required=True,
                   help='The output CSV file generated by the Cacher.')
    p.add_argument('-p', '--repo-clone-path',
                   help='The path to the directory where repos should be/already are cloned. If not given, repos will '
                   'be cloned to a temporary directory.')
    return p.parse_args()


def main():
    log.config_logging('INFO')
    args = _validate_input()
    with open(args.build_pair_json) as f:
        build_pairs = json.load(f)

    with open(args.cacher_csv) as f:
        cache_results = [*csv.reader(f, skipinitialspace=True, quoting=csv.QUOTE_NONE)]

    if args.repo_clone_path:
        clone_path = args.repo_clone_path
    else:
        # Temporary directory will be removed when `tempdir` variable goes out of scope at the end of main()
        tempdir = tempfile.TemporaryDirectory()
        clone_path = tempdir.name

    image_tag_to_bp = {}
    for bp in build_pairs:
        dashed_repo = bp['repo'].replace('/', '-')
        for jp in bp['jobpairs']:
            image_tag = '{}-{}'.format(dashed_repo, jp['failed_job']['job_id'])
            image_tag_to_bp[image_tag] = bp

    errors = {}
    for image_tag, result, *_ in cache_results:
        if result != 'succeed':
            log.info("Skipping {} since it couldn't be cached".format(image_tag))
            continue

        if image_tag not in image_tag_to_bp:
            log.error("Skipping {} since it isn't present in {}. Perhaps you reused a task name?".format(
                image_tag, args.build_pair_json))
            continue

        bp = image_tag_to_bp[image_tag]
        repo_clone_path = os.path.join(clone_path, bp['repo'])
        try:
            _add_diff_for_artifact(image_tag, bp, repo_clone_path)
        except Exception as e:
            log.error('Could not add diff for {}: {!r}'.format(image_tag, e))
            errors[image_tag] = e

    if errors:
        log.error('The following image tags could not have their diffs uploaded:')
        for image_tag, error in errors.items():
            log.error('{}: {!r}'.format(image_tag, error))
        return 1


if __name__ == '__main__':
    sys.exit(main())
