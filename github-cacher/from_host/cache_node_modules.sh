#!/bin/bash

# Print commands as they're executed, exit on error, fail in pipelines
set -eo pipefail

# Check if a Bash array contains the given element
# Adapted from https://stackoverflow.com/a/8574392
elementIn() {
    local e match="$1"
    shift
    for e in "$@"; do
        if [[ "$e" == "$match" ]]; then
            return 0
        fi
    done
    return 1
}

target_dir="$(realpath "$1")"
output_tar="$(realpath "$2")"

# Add all `node_modules` folders to the archive
mapfile -td '' dirs_to_archive < <(find "$target_dir" -name node_modules -prune -print0)

# Work around a limitation of tar: if the parent directories of a compressed
# file don't exist and aren't in the tarfile, they will be created with the
# *calling* user as the owner instead of the owner of the compressed file. This
# causes problems for us since we untar the dependencies as root. The solution
# is to include the paths of all parent dirs in the tar file (but not their
# contents!)
parent_dirs=()
for dir in "${dirs_to_archive[@]}"; do
    temp_array=()
    dir="$(dirname "$dir")"
    while [[ "$dir" != "$target_dir" ]] && ! elementIn "$dir" "${parent_dirs[@]}"; do
        temp_array=("$dir" "${temp_array[@]}")
        dir="$(dirname "$dir")"
    done
    parent_dirs=("${parent_dirs[@]}" "${temp_array[@]}")
done

# Add ~/.npm to the archive if it exists
if [[ -d "$HOME/.npm" ]]; then
    dirs_to_archive=("${dirs_to_archive[@]}" "$HOME/.npm")
fi

# Create the tar file
temp_tar="$(mktemp)"

# Add parent dirs
if [[ "${#parent_dirs[@]}" -gt 0 ]]; then
    echo "Adding parent dirs"
    tar --no-recursion -rvf "$temp_tar" "${parent_dirs[@]}"
fi

# Add node_modules and ~/.npm
if [[ "${#dirs_to_archive[@]}" -gt 0 ]]; then
    echo "Adding node files"
    tar -rvf "$temp_tar" "${dirs_to_archive[@]}"
fi

# Gzip the tar
gzip -c "$temp_tar" > "$output_tar"
rm "$temp_tar"
