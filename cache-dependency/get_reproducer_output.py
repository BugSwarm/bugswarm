import argparse
import json
import os
import sys


def main(argv):
    in_paths, out_path = _validate_input(argv)

    buildpairs = []
    for path in in_paths:
        with open(path) as f:
            buildpairs += json.load(f)

    to_be_cached = []
    for bp in buildpairs:
        # Only accept reproducible build pairs
        if 'match' not in bp or bp['match'] != 1:
            continue

        # Make sure language is Java
        java_jobs = []
        for job in bp['failed_build']['jobs']:
            if job['language'] == 'java':
                java_jobs.append(job['job_id'])
        for job in bp['passed_build']['jobs']:
            if job['language'] == 'java':
                java_jobs.append(job['job_id'])

        # Cache all reproducible & unfiltered job pairs that use Java & Maven
        prefix = bp['repo'].replace('/', '-') + '-'
        for jp in bp['jobpairs']:
            should_be_cached = (not jp['is_filtered'] and
                                jp['build_system'] == 'Maven' and
                                jp['failed_job']['job_id'] in java_jobs and
                                jp['passed_job']['job_id'] in java_jobs)
            if should_be_cached:
                to_be_cached.append(prefix + str(jp['failed_job']['job_id']))

    try:
        os.mkdir('input')
    except FileExistsError:
        pass

    with open(out_path, 'w') as f:
        for image_tag in to_be_cached:
            f.write(image_tag + '\n')


def _validate_input(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input-path', required=True, nargs='+',
                        help='Path to an input file generated by the Reproducer. Multiple files can be specified.')
    parser.add_argument('-o', '--task-name', required=True,
                        help='Name of task.')
    opts = parser.parse_args(argv[1:])

    for path in opts.input_path:
        if not os.path.isfile(path):
            print('"{}" does not exist or is not a regular file. Exiting.'.format(path))
            parser.print_usage()
            sys.exit(1)

    return opts.input_path, 'input/' + opts.task_name


if __name__ == '__main__':
    sys.exit(main(sys.argv))
